## ユースケース
CBSはクラウドにおいて拡張可能なストレージデバイスであり、いつでもCBSを作成してサイズを拡張できます。ストレージキャパシティーを増やし、同時にCBSの元のデータが損失されません。
[CBSのスケールアウト](https://intl.cloud.tencent.com/document/product/362/5747) が完了した後、スケールアウトした容量を既存のパーティションに割り当て、またはスケールアウトした容量を独立した新しいパーティションにフォーマットする必要があります。



## 前提条件
>不適切なファイルシステムのスケールアウト操作は既存のデータに影響を与える可能性があるため、操作する前に手動で[スナップショットを作成して](https://intl.cloud.tencent.com/document/product/362/5755) データをバックアップすることを強くお勧めします。
>
- [CBSをスケールアウト](https://intl.cloud.tencent.com/document/product/362/5747) しました。
- このCBSがすでにLinux CVMに[マウント](https://intl.cloud.tencent.com/document/product/362/5745) されており、ファイルシステムも作成されました。
- 拡張待ちパーティションとファイルシステムのLinux CVMに[ログイン](https://intl.cloud.tencent.com/document/product/213/5436) しました。

## 操作手順
### 拡張方法を確認する
<span id="fdisk"></span>
1. rootユーザーとして次のコマンドを実行し、CBSが利用したパーティション形式を確認します。
```
fdisk -l
```
 - 表示されたデバイスはパーティションがない場合（/dev/vdbのみ表示された）、[ファイルシステムのスケールアウト](#ExpandTheFileSystem)をご参照ください。
 - 結果が下記の2つの図に示されている場合（OSによって異なる）、GPTパーティション形式が使用されていることになります。
![](https://main.qcloudimg.com/raw/5ff70adb58a223d32d334470c5b29e0e.png)
![](https://main.qcloudimg.com/raw/ce19715fc8494a9735b714d86f0cccfa.png)
 - 結果が下記の2つの図に示されている場合（OSによって異なる）、MBRパーティション形式が使用されていることになります。
 > MBRパーティション形式は、最大2TBのディスク容量をサポートします。ディスクのパーティションがMBR形式であり、2TB以上にスケールアウトする必要がある場合、新しいデータディスクを作成し、マウントして、GPTパーティション方式を利用してデータを新しいディスクにコピーすることをお勧めします。Linux OSの場合、ディスクのパーティション形式がGPTを利用する時に、fdiskパーティションツールは利用できないため、partedツールを利用してください。
 >
![](https://main.qcloudimg.com/raw/0e336cd3354c098cf5e70d0672e6f625.png)
2. [ステップ1](#fdisk) で確認したCBSパーティション形式に応じて、該当する操作ガイドを選択します。
<table>
     <tr>
         <th nowrap="nowrap">パーティション形式</th>  
         <th>操作ガイド</th>  
         <th>説明</th>  
     </tr>
		 	 <tr>      
         <td>-</td>   
	     <td nowrap="nowrap"><a href="#ExpandTheFileSystem">ファイルシステムをスケールアウトする</a></td>
	     <td>パーティションを作成しない状態で、初期デバイスでファイルシステムを直接作成するユースケースに適しています。</td>
     </tr>
	 <tr>      
         <td rowspan="2">GPT</td>   
	     <td nowrap="nowrap"><a href="#AddToTheExistingGPTPart">スケールアウトした容量を元のパーティション（GPT）に割り当てる</a></td>
	     <td>パーティションしない状態で直接フォーマットするユースケースに適しています。</td>
     </tr> 
	 <tr>
         <td><a href="#CreateANewGPTPart">スケールアウトした容量を独立した新しいパーティション（GPT）にフォーマットする</a></td> 
	     <td>元のパーティションを変更せずに維持できます。</td>
     </tr> 
	 <tr>
         <td rowspan="2">MBR</td>   
	     <td><a href="#AddToTheExistingMBRPart">スケールアウトした容量を元のパーティション（MBR）に割り当てる</a></td> 
	     <td>パーティションしない状態で直接フォーマットするユースケースに適しています。</td>
     </tr> 
	 <tr>
         <td><a href="#CreateANewMBRPart">スケールアウトした容量を独立した新しいパーティション（MBR）にフォーマットする</a></td> 
	     <td>元のパーティションを変更せずに維持できます。</td>
     </tr> 
</table>

<span id="ExpandTheFileSystem"></span>
### ファイルシステムをスケールアウトする

1. ファイルシステムの種類に応じて、異なるコマンドを実行してスケールアウトします。
 - EXTファイルシステムの場合、 `resize2fs` コマンドを実行してファイルシステムをスケールアウトします。
 - XFSファイルシステムの場合、`xfs_growfs`コマンドを実行してファイルシステムをスケールアウトします。

 `/dev/vdb` を例として、EXTファイルシステムは次のコマンドを実行する：
```
resize2fs /dev/vdb
```
`/dev/vdb` を例として、 XFSファイルシステムは次のコマンドを実行する：
```
xfs_growfs /dev/vdb
```
2. 次のコマンドを実行して、新しいパーティションを確認します。
```
df -h
```

<span id="AddToTheExistingGPTPart"></span>
### スケールアウトした容量を元のパーティション（GPT）に割り当てる
1. rootユーザーとして次のコマンドを実行し、CBS容量の変更を確認します。
 ```
parted <ディスクパス> print
```
このドキュメントでは、ディスクパスは `/dev/vdb`を例として、次のコマンドを実行する：
```
parted /dev/vdb print
```
実行中に下図に示すような情報が表示された場合、`Fix`を入力してください。
![](//mccdn.qcloud.com/static/img/cf51cda9a12085f76949ab0d5dd0fbfc/image.png)
下図に示すように、スケールアウトしたCBSのサイズは107GBであり、既存のパーティションのサイズは10.7GBです。
![](//mccdn.qcloud.com/static/img/01a0a7a8fdfe6f05f2739f0326a74ef9/image.png)

2. 次のコマンドを実行して、このCBSにマウントされたパーティションがあるかどうかを確認します。
```
mount | grep '<ディスクパス>' 
```
このドキュメントでは、ディスクパスは`/dev/vdb`を例として、次のコマンドを実行する：
```
mount | grep '/dev/vdb'
```
下図に示すように、CBSの中で一つのパーティション（vdb1）が`/data`にマウントされています。
![](//mccdn.qcloud.com/static/img/edc5bbd6834e1dd929ce0eb00acd53ca/image.png)
3. 次のコマンドを実行して、データディスクをアンマウントします。
```
umount <マウントポイント>
```
このドキュメントでは、マウントポイントは`/data`を例として、次のコマンドを実行する：
```
umount /data
```
> CBS上のすべてのパーティションのファイルシステムをアンマウントしてから、[ステップ4](#step4) を実行してください。次のコマンドを繰り返し実行して、ディスク上のすべてのパーティションのファイルシステムがアンマウントされたことを確認します。
```
mount | grep '/dev/vdb'
```
CBS上のすべてのパーティションのファイルシステムがアンマウントされました。 下図に示すように：
![](https://main.qcloudimg.com/raw/9242efdec1aab382ae74f975ca68d68a.png)

<span id="step4"></span>
4. 次のコマンドを実行して、parted パーティションツールに入ります。
```
parted '<ディスクパス>'
```
このドキュメントでは、ディスクパスは`/dev/vdb`を例として、次のコマンドを実行する：
```
parted '/dev/vdb'
```
5. 次のコマンドを実行して、表示と操作の単位をsector（デフォルトはGB）に変更します。
```
unit s
```
6. `print`を入力してパーティション情報を確認し、既存のパーティションのStart値を記録します。
> パーティションを削除して新規作成した後、Start 値は変更をせずにそのままにする必要があります。そうでなければ、データの損失が発生します。

 ![](//mccdn.qcloud.com/static/img/67ba54c1d9d63c307d4b8a157b70c722/image.png)
7. 次のコマンドを実行して、元のパーティションを削除します。
```
rm <パーティション Number>
```
例えば、上図に示すようにCBSの中で一つのパーティションがあり、Numberが「1」です。次のコマンドを実行する：
```
 rm 1
```
返却情報は下図に示します。
![](//mccdn.qcloud.com/static/img/3384eeada87ce75695e0e55125109eff/image.png)
5. 次のコマンドを実行して、一つのプライマリパーティションを新規作成します。
```
mkpart primary <元のパーティションの初期セクター> 100%
```
100％は、このパーティションがディスクの最後にあることを示します。
例えば、プライマリパーティションは2048番目のセクターから始まり（削除前のパーティションと一致する必要があり、Start 値は2048ｓ）、次のコマンドを実行する：
```
mkpart primary 2048s 100%
```
下図に示す状態が表示された場合、`Ignore`を入力します。
![](//mccdn.qcloud.com/static/img/c45966e20dc856817c65fd6b81155e4a/image.png)
6. 次のコマンドを実行して、新しいパーティションが正常に作成されたかどうかを確認します。
```
print
```
返却結果は下図に表示された場合、新しいパーティションが正常に作成されたことを示します。
![](//mccdn.qcloud.com/static/img/cb1af5adaf6c89d066077c43fd428a38/image.png)
7. 次のコマンドを実行して、partedツールを終了します。
```
quit
```
11. 次のコマンドを実行して、スケールアウトしたパーティションを確認します。
```
e2fsck -f <パーティションパス>
```
このドキュメントでは、新規作成のパーティションは1（即ちパーティションパスは `/dev/vdb1`である）を例として、次のコマンドを実行する：
```
e2fsck -f /dev/vdb1
```
下図に示すような結果を返します。
![](//mccdn.qcloud.com/static/img/307f7a0c98eea05ca1d4560fe4e96f57/image.png)
12. 次のコマンドを実行して、新しいパーティションでのEXT ファイルシステムをスケールアウトします。
```
resize2fs <パーティションパス>
```
このドキュメントでは、パーティションパスは`/dev/vdb1`を例として、次のコマンドを実行する：
```
resize2fs /dev/vdb1
```
スケールアウトが成功したら、下図に示すように：
![](//mccdn.qcloud.com/static/img/57d66da9b5020324703498dbef0b12f9/image.png)
13. 次のコマンドを実行して、新しいパーティションでのXFS ファイルシステムをスケールアウトします。
```
xfs_growfs <パーティションパス>
```
このドキュメントでは、パーティションパスは`/dev/vdb1`を例として、次のコマンドを実行する：
```
xfs_growfs /dev/vdb1
```
14. 次のコマンドを実行して、新しいパーティションを手動でマウントします。
```
mount <パーティションパス> <マウントポイント>
```
このドキュメントでは、パーティションパスは`/dev/vdb1`とマウントポイントは`/data`を例として、次のコマンドを実行する：
```
mount /dev/vdb1 /data
```
15. 次のコマンドを実行して、新しいパーティションを確認します。
```
df -h
```
下図のような情報が返されたら、マウントが成功したことを示します。即ちデータディスクを確認できます。
![](//mccdn.qcloud.com/static/img/a2bd04c79e8383745689e19033a0daaa/image.png)

<span id="CreateANewGPTPart"></span>
### スケールアウトした容量を独立した新しいパーティション（GPT）にフォーマットする

1. rootユーザーとして次のコマンドを実行して、CBS容量の変更を確認します。
 ```
parted <ディスクパス> print
```
このドキュメントでは、ディスクパスは`/dev/vdb`を例として、次のコマンドを実行する：
```
parted /dev/vdb print
```
実行中に下図に示すような情報が表示された場合、`Fix`を入力してください。
![](//mccdn.qcloud.com/static/img/cf51cda9a12085f76949ab0d5dd0fbfc/image.png)
下図に示すように、スケールアウトしたCBSのサイズは107GBであり、既存のパーティションのサイズは10.7GBです。
![](//mccdn.qcloud.com/static/img/01a0a7a8fdfe6f05f2739f0326a74ef9/image.png)
2. 次のコマンドを実行して、このCBSの中でマウントされたパーティションがあるかどうかを確認します。
```
mount | grep '<ディスクパス>' 
```
このドキュメントでは、ディスクパスは`/dev/vdb`を例として、次のコマンドを実行する：
```
mount | grep '/dev/vdb'
```
下図に示すように、CBSの中で一つのパーティション（vdb1）が`/data`にマウントされています。
![](//mccdn.qcloud.com/static/img/edc5bbd6834e1dd929ce0eb00acd53ca/image.png)
3. 次のコマンドを実行して、データディスクをアンマウントします。
```
umount <マウントポイント>
```
このドキュメントでは、マウントポイントは`/data`を例として、次のコマンドを実行する：
```
umount /data
```
> CBS上のすべてのパーティションのファイルシステムをアンマウントしてから、[ステップ4](#step4) を実行してください。次のコマンドを繰り返し実行して、ディスク上のすべてのパーティションのファイルシステムがアンマウントされたことを確認します。
```
mount | grep '/dev/vdb'
```
CBS上のすべてのパーティションのファイルシステムがアンマウントされました。下図に示すように：
![](https://main.qcloudimg.com/raw/d1a9a33f0d4e3725aed677f2403c91ae.png)
<span id="Step4"></span>
4. 次のコマンドを実行して、parted パーティションツールに入ります。
```
parted '<ディスクパス>'
```
このドキュメントでは、ディスクパスは`/dev/vdb`を例として、次のコマンドを実行する：
```
parted '/dev/vdb'
```
5. 次のコマンドを実行して、パーティション情報を確認し、既存のパーティションのEnd値を記録し、この値を次のパーティションの初期オフセット値として使用されます。
```
print
```
![](//mccdn.qcloud.com/static/img/788ce125bba952f204ed6ee36dfb644d/image.png)
6. 次のコマンドを実行して、一つのプライマリパーティションを新規作成します。このパーティションは、既存のパーティションの最後から始まり、ディスク上のすべての新しいキャパシティーを上書きします。
```
mkpart primary start end
```
このドキュメントはEnd値が10.7 GBを例として、次のコマンドを実行する：
```
mkpart primary 10.7GB 100%
```
7. 次のコマンドを実行して、新しいパーティションが正常に作成されたかどうかを確認します。
```
print
```
![](//mccdn.qcloud.com/static/img/fc54fd4c05102ee91c648526d77d1b42/image.png)
8. 次のコマンドを実行して、partedツールを終了します。
```
quit
```
9. 次のコマンドを実行して、新規作成したパーティションをフォーマットします。
```
mkfs.<fstype> <パーティションパス> 
```
ファイルシステムの形式を自由に選択でき、例えばEXT2、EXT3など。
このドキュメントでは、ファイルシステムはEXT3を例として、次のコマンドを実行する： 
```
mkfs.ext3 /dev/vdb2
```

<span id="AddToTheExistingMBRPart"></span>
### スケールアウトした容量を元のパーティション（MBR）に割り当てる
fdisk/e2fsck/resize2fs 自動スケールアウトツールはLinux OSに適し、新しくスケールアウトされたCBSキャパシティーを既存のファイルシステムに追加します。スケールアウトの成功には、次の4つの条件を満たす必要があります。
- ファイルシステムは EXT2/EXT3/EXT4/XFS です。
- カレントのファイルシステムにエラーがありません。
- スケールアウトされたディスクの容量は2TBを超えることはできません。
- カレントのツールはPython 2バージョンのみサポートし、Python 3バージョンはサポートしていません。


1. rootユーザーとして次のコマンドを実行して、パーティションをアンマウントします。
```
umount <マウントポイント>
```
このドキュメントでは、マウントポイントは`/data`を例として、次のコマンドを実行する：
```
umount /data
```
![](//mccdn.qcloud.com/static/img/c0acc05057941681627a5fd34979d194/image.jpg)
2. 次のコマンドを実行して、ツールをダウンロードします。
```
wget -O /tmp/devresize.py https://raw.githubusercontent.com/tencentyun/tencentcloud-cbs-tools/master/devresize/devresize.py
```
3. 次のコマンドを実行して、スケールアウトツールを利用してスケールアウトします。
```
python /tmp/devresize.py <ディスクパス>
```
このドキュメントでは、ディスクパスは`/dev/vdb`であり、およびファイルシステムはvdb1にあることを例として、次のコマンドを実行する：
```
python /tmp/devresize.py /dev/vdb
```
![](//mccdn.qcloud.com/static/img/c7617b90578192d64d19f02325f00ffb/image.jpg)
 - 出力が「The filesystem on /dev/vdb1 is now XXXXX blocks long.」の場合、スケールアウトが成功したことを示し、 [ステップ4](#step4MBR)を実行してください。
 - 出力が 「[ERROR] - e2fsck failed!!」の場合、以下の手順を実行してください：
   a. 次のコマンドを実行して、ファイルシステムが所属しているパーティションを修復します。
```
fsck -a <パーティションパス>
```
このドキュメントでは、ディスクパスは`/dev/vdb`であり、およびファイルシステムはvdb1にあることを例として、次のコマンドを実行する：
```
fsck -a /dev/vdb1
```
    b. 修復が完了した後、次のコマンドを再度実行し、スケールアウトツールを利用してスケールアウトします。
```
python /tmp/devresize.py /dev/vdb
```
<span id="step4MBR"></span>
4. 次のコマンドを実行して、スケールアウトされたパーティションを手動でマウントします。
```
mount <パーティションパス> <マウントポイント>
```
このドキュメントでは、マウントポイントは`/data`を例とします。
 - スケールアウトする前にすでにパーティションがあり、およびパーティションパスが `/dev/vdb1`を例として、次のコマンドを実行する：
```
mount /dev/vdb1 /data
```
 - スケールアウトする前にパーティションがない場合、次に実行する：
```
mount /dev/vdb /data
```
5. 次のコマンドを実行して、スケールアウトした後のパーティションの容量を確認します。
```
df -h
```
下図に示すような情報が返された場合、マウントが成功したことを示しており、データディスクを確認できます。
![](//mccdn.qcloud.com/static/img/2367f3e70cd0c3c1bef665cc47c1c3bc/image.jpg)
6.　次のコマンドを実行して、スケールアウトした後に元のパーティションのデータ情報を確認し、新しく追加されたストレージキャパシティーがファイルシステムにスケールアウトされているかどうかを確認します。
```
ll /data
```

<span id="CreateANewMBRPart"></span>
### スケールアウトした容量を独立した新しいパーティション（MBR）にフォーマットする
1. rootユーザーとして次のコマンドを実行して、マウントされたデータディスクのパーティション情報を確認します。
```
df -h
```
![](//mccdn.qcloud.com/static/img/0a450dfaa9cfc7b2c7fdc04861f0e754/image.png)
2. 次のコマンドを実行して、データディスクをスケールアウトした後にまだパーティションされていない情報を確認します。
```
fdisk -l
```
![](//mccdn.qcloud.com/static/img/594671a1215dee3036b7940892438f62/image.png)
3. 次のコマンドを実行して、マウントされているすべてのパーティションをアンマウントします。
```
umount <マウントポイント>
```
このドキュメントでは、マウントポイントは`/data`を例として、次のコマンドを実行する：
```
umount /data
```
> CBS上のすべてのパーティションをアンマウントしてから、[ステップ4](#Step4MBR)を実行してください。
<span id="Step4MBR"></span>
4. 次のコマンドを実行して、パーティションを新規作成します。
```
fdisk <ディスクパス>
```
このドキュメントでは、ディスクパスは`/dev/xvdc`を例として、次のコマンドを実行する：
```
fdisk /dev/xvdc
```
インターフェースのプロンプトに従って、順次に「p」（既存のパーティション情報を確認する）、「n」（パーティションを新規作成する）、「p」（プライマリパーティションを新規作成する）、「2」（2番目のプライマリパーティションを新規作成する）を入力し、2回エンターし（デフォルトの構成を利用する）、「w」（パーティションテーブルを保存する）を入力し、パーティション処理を開始します。 下図に示すように：
![](//mccdn.qcloud.com/static/img/8c35d6f4dfb367e74edc27ce6822c317/image.png)
> このドキュメントでは、パーティションの作成を例として、実際のニーズに応じて複数のパーティションを作成することもできます。
5. 次のコマンドを実行して、新しいパーティションを確認します。
```
fdisk -l
```
下図に示すように、新しいパーティションxvdc2が作成されたことを示します。
![](//mccdn.qcloud.com/static/img/e04e924d62317bc2c605c8abaac394f5/image.png)
6. 次のコマンドを実行して、新しいパーティションをフォーマットし、ファイルシステムを作成します。
```
mkfs.<fstype> <パーティションパス> 
```
ファイルシステムの形式を自由に選択でき、例えばEXT2、EXT3など。
このドキュメントでは、ファイルシステムはEXT3を例として、次のコマンドを実行する：
```
mkfs.ext3 /dev/xvdc2
```
![](//mccdn.qcloud.com/static/img/074e23eaa580495f96fb532b688d2d68/image.png)
7. 次のコマンドを実行して、新しいマウントポイントを作成します。
```
mkdir <新しいマウントポイント>
```
このドキュメントでは、新しいマウントポイントは `/data1`を例として、次のコマンドを実行する：
```
mkdir /data1
```
8. 次のコマンドを実行して、新しいパーティションを手動でマウントします。
```
mount <新しいパーティションパス> <新しいマウントポイント>
```
このドキュメントでは、新しいパーティションパスは`/dev/xvdc2`であり、新しいマウントポイントは`/data1`を例として、次のコマンドを実行する：
```
mount /dev/xvdc2 /data1
```
9. 次のコマンドを実行して、新しいパーティション情報を確認します。
```
df -h
```
下図に示すような情報が返された場合、マウントが成功したことを示し、データディスクを確認できます。
![](//mccdn.qcloud.com/static/img/7b749a4bb6e7c8267c9354e1590c35d4/image.png)

> CVMがリスタートまたはスタートアップする時にデータディスクを自動的にマウントさせる場合、[ステップ10](#AddNewPartINFOstep10) および[ステップ11](#AddNewPartINFOstep11) を実行して新しいパーティション情報を`/etc/fstab`に追加する必要があります。

<span id="AddNewPartINFOstep10"></span>
10. 次のコマンドを実行して、情報を追加します。
```
echo '/dev/xvdc2 /data1 ext3 defaults 0 0' >> /etc/fstab
```
<span id="AddNewPartINFOstep11"></span>
11. 次のコマンドを実行して、情報を確認します。
```
cat /etc/fstab
```
下図に示すような情報が返された場合、パーティション情報が正常に追加されたことを示します。
![](//mccdn.qcloud.com/static/img/f0b5c14bf08fd3629ddf6d9b1ae01ffc/image.png)

## 関連操作
[パーティションとファイルシステム（Windows）を拡張する](https://intl.cloud.tencent.com/document/product/362/6737)
