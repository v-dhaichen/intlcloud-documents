## 동일 오리진 정책
동일 오리진 정책은 하나의 소스로부터 로딩한 문서 또는 스크립트가 다른 한 소스의 리소스와 인터랙션하는 방식을 제한하고 잠재된 악의적 파일을 격리하는 핵심 보안 메커니즘입니다. 동일한 프로토콜, 동일한 도메인 이름(또는 IP), 및 동일한 포트를 동일한 도메인으로 간주하고 한 개 도메인 내의 스크립트는 단지 본 도메인 내의 권한만을 가집니다. 즉 본 도메인 스크립트는 본 도메인 내의 리소스만을 읽고 쓸 수 있으며 기타 도메인의 리소스에 접근할 수 없습니다. 이러한 보안 제한을 동일 오리진 정책이라고 부릅니다. 
### 동일 오리진의 정의
두 개 페이지의 프로토콜, 도메인 이름과 포트(포트를 지정했을 경우)가 동일할 때, 동일 오리진으로 간주합니다. 아래 표에서는 `http://www.example.com/dir/page.html`에 상대하여 동일 오리진의 검사 예시를 제공했습니다.

| **URL** | **결과** | **원인** |
|:---------:|:---------:|:---------:|
| `http://www.example.com/dir2/other.html` | 성공 | 프로토콜, 도메인 이름, 및 포트가 같음 |
| `http://www.example.com/dir/inner/another.html` |	성공 | 프로토콜, 도메인 이름, 및 포트가 같음 |
| `https://www.example.com/secure.html` |	실패	| 프로토콜( HTTPS)이 다름 |
| `http://www.example.com:81/dir/etc.html` |	실패 |	포트(81)가 다름 |
|`http://news.example.com/dir/other.html` |	실패 |	도메인 이름이 다름 |
### 크로스 도메인 액세스
크로스 도메인 리소스 공유(CORS) 메커니즘을 당사는 크로스 도메인 액세스라고 부릅니다. Web 응용프로그램 서버의 크로스 도메인 액세스 제어를 허용하여 크로스 도메인 데이터 전송이 안전하게 진행되도록 합니다. CORS는 브라우저와 서버의 동시 지원을 필요로 합니다. 현재 모든 브라우저는 이 기능을 지원하고 IE 브라우저는 IE10 또는 그 이상의 버전이 요구됩니다.
전체 CORS의 통신 과정은 모두 브라우저가 자동으로 완성하며 사용자가 참여할 필요가 없습니다. 개발자에게 CORS 통신과 동일 오리진의 AJAX 통신은 차이점이 없으며 코드가 완전히 같습니다. 브라우저는 AJAX의 오리진 간 요청을 발견할 경우 일부 추가적 헤드 정보를 자동으로 추가하고 가끔 1차의 추가 요청이 많아지게 되지만 사용자는 이를 느끼지 못합니다.
그러므로 CORS 통신을 구현하는 핵심은 서버입니다. 서버가 CORS API를 구현하기만 하면 오리진 간의 통신을 진행할 수 있습니다.

## CORS 주요 사용 시나리오
CORS는 반드시 브라우저를 사용하는 상황에서만 사용되어야 합니다. 그 이유는 접근 권한을 제어하는 것은 서버가 아닌 브라우저이기 때문입니다. 그러므로 기타 클라이언트를 사용할 때 모든 크로스 도메인 문제를 신경 쓸 필요가 없습니다.
CORS의 주요한 응용프로그램은 업로드하거나 다운로드를 진행할 때 브라우저에서 AJAX를 사용하여 COS의 데이터에 직접 접근하며 사용자 자체의 응용프로그램 서버에서 전환할 필요가 없습니다. COS와 AJAX 기술을 동시에 사용하는 사이트에서 CORS를 사용하여 COS와의 직접 통신을 구현할 것을 권장합니다.
## COS의 CORS에 대한 지원
COS는 CORS 규칙에 대한 구성을 지원하고 수요에 따라 해당하는 크로스 도메인 요청을 허용하거나 거절합니다. 해당 CORS 규칙 구성은 버킷 레벨에 속합니다.
CORS 요청의 통과 여부는 COS의 신분 인증 등과는 완전하게 독립되는 것입니다. 즉 COS의 CORS 규칙은 단지 CORS에 관련되는 Header의 한 개 규칙을 추가할 것인지 결정하는 것 뿐입니다. 이 요청을 블록 진행 여부는 완전히 브라우저가 결정합니다.
현재 COS의 모든 Object 관련 API는 모두 CORS 관련 인증을 제공하였고 이외에 Multipart API도 현재 CORS 인증을 완전 지원합니다.
> 동일한 브라우저에서 실행되는 각각 `www.a.com`과 `www.b.com`에서 출처한 두 페이지가 동일한 크로스 도메인 리소스를 동시 요청할 때 `www.a.com`의 요청이 먼저 서버에 도착하면 서버는 리소스가 Access-Control-Allow-Origin의 Header를 가지게 하며 `www.a.com`의 사용자에게 반환합니다. 이 때 `www.b.com`에서 또 요청을 보낼 경우 브라우저는 Cache의 이전 요청 응답을 사용자에게 반환하고 Header의 콘텐츠와 CORS의 요구가 매칭되지 않을 경우 `www.b.com`의 요청이 실패하게 됩니다.

## CORS 설정 예시
아래에는 AJAX를 사용하여 COS로부터 데이터의 구성을 얻는 절차를 간단한 예시로 소개합니다. 예시 중 사용하는 버킷(Bucket) 권한을 공개(Public)로 설정하고 접근 권한을 비공개로 설정한 버킷(Bucket)은 요청 중에 서명만 추가하면 되고 기타 구성은 같습니다.
아래 예시에서 사용하는 버킷 이름은 corstest이고 버킷 접근 권한은 공개 읽기 및 비공개 쓰기입니다.
### CORS 설정 전
1. **파일의 정상 접근 가능성 확인**
한 개 test.txt의 파일 문서를 corstest에 업로드합니다. test.txt의 접근 주소는 `http://corstest-125xxxxxxx.cos.ap-beijing-1.myqcloud.com/test.txt`입니다.
Curl을 사용하여 본 파일 문서를 직접 접근하고 아래 주소를 본인의 파일 주소로 대체합니다.
```
curl http://corstest-125xxxxxxx.cos.ap-beijing-1.myqcloud.com/test.txt
```
test.txt 파일 반환 내용: test. 본 문서에 정상적으로 접근할 수 있음을 표시합니다.
![이미지 0](//mc.qcloudimg.com/static/img/5e1740ac46efd2ddcb8258448af27815/image.png)
2. **AJAX 기술로 문서 접근**
당사는 현재 AJAX 기술을 사용하여 본 test.txt 파일에 직접적으로 접근하고자 합니다.
 1. 간단한 HTML 문서를 작성하고 아래 코드를 로컬에 복사하여 HTML 파일로 저장한 후 브라우저를 사용하여 실행합니다. 사용자 지정의 헤드를 설정하지 않았으므로 본 요청은 사전 검사할 필요가 없습니다.
```
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
<a href="javascript:test()">Test CORS</a>
<script>
    function test() {
        var url = 'http://corstest-125xxxxxxx.cos.ap-beijing-1.myqcloud.com/test.txt';
        var xhr = new XMLHttpRequest();
        xhr.open('HEAD', url);
        xhr.onload = function () {
            var headers = xhr.getAllResponseHeaders().replace(/\r\n/g, '\n');
            alert('request success, CORS allow.\n' +
                'url: ' + url + '\n' +
                'status: ' + xhr.status + '\n' +
                'headers:\n' + headers);
        };
        xhr.onerror = function () {
            alert('request error, maybe CORS error.');
        };
        xhr.send();
    }
</script>
</body>
</html>
```
 2. 브라우저에서 본 HTML 파일을 열고 [Test CORS] 버튼을 클릭하여 요청을 보내면 아래와 같은 오류가 발생합니다. 오류 메시지: 접근 권한이 없습니다. 그 이유는 Access-Control-Allow-Origin이라는 Header를 찾지 못했기 때문입니다. 물론 이것은 서버가 CORS를 구성하지 않았기 때문입니다.
 ![오류 메시지](//mc.qcloudimg.com/static/img/b495296d08ddac2f5d8eacc0e9203c59/image.png)
 3. 접근 실패 시 Header 인터페이스에 다시 액세스하여 원인을 검사합니다. 보다시피 브라우저는 Origin을 가지는 Request를 보냈으므로 이 것은 하나의 크로스 도메인 요청입니다.
![Header 검사](//mc.qcloudimg.com/static/img/26976dee6cb15736e9aff86d353d5738/image.png)
> 당사는 웹페이지를 서버에 탑재하였고 주소는 `http://127.0.0.1:8081`이므로 Origin은 `http://127.0.0.1:8081`입니다.

### CORS 설정
접근이 실패한 원인을 확인한 후 버킷 관련 CORS를 설정하는 것으로 위의 문제들을 해결할 수 있습니다. COS 콘솔은 CORS 설정을 진행할 수 있으므로 본 예시에서는 콘솔을 사용하여 CORS의 설정을 완성합니다. 귀하의 CORS 설정이 특별히 복잡하지 않을 경우 콘솔을 사용하여 CORS를 설정하는 것도 권장합니다.
#### I. COS 콘솔에 로그인하여 구성 페이지에 액세스합니다.
[COS 콘솔]()을 클릭하여 로그인하고 [Bucket 리스트]를 클릭한 다음 관련 버킷(Bucket, 예 corstest)에 들어가 [기본 구성]을 클릭하면 크로스 도메인 액세스 CORS 설정 항목을 찾을 수 있습니다.
![이미지 4](//mc.qcloudimg.com/static/img/7a08a4ad4199580265a0359f2b39eafc/image.png)

#### II. CORS 규칙의 시작 및 설정 
1. [편집]을 클릭하여 CORS 상태를 시작한 후 [+규칙 생성]을 클릭하면 설정 페이지가 나타난 다음 첫 번째 규칙을 추가합니다. 가장 원활한 구성은 다음과 같습니다.
![](//mc.qcloudimg.com/static/img/198d6464fe3846451b6afc2b71cb0b78/image.png)
> **주의:**
> CORS 설정은 각 규칙으로 구성되며 첫 번째 규칙으로부터 순서에 따라 점차 매칭되고 가장 최초 매칭된 규칙을 기준으로 합니다.

#### 인증 결과
구성 완료 후 test.txt 문서 파일의 접근을 재시도합니다. 결과는 아래와 같으며 정상적으로 접근을 요청할 수 있습니다.
![접근 성공](//mc.qcloudimg.com/static/img/9d3f4370b337e73090efae2c2ef199f4/image.png)

### 고장 제거 및 권장 사항
크로스 도메인에 의해 생긴 접근 문제를 제거하려면 CORS를 상기 가장 원활한 구성으로 설정할 수 있습니다. 본 구성은 모든 크로스 도메인 요청을 허용합니다. 본 구성에서 여전히 오류가 발생한다면 CORS가 아닌 다른 부분에 오류가 생겼다는 것을 의미합니다.

가장 원활한 구성 외에 귀하는 또한 더 정밀한 컨트롤 메커니즘을 구성하여 맞춤형 컨트롤을 구현할 수 있습니다. 예를 들어 본 예시에 관하여 아래와 같은 가장 작은 할당 구성을 사용하여 매칭에 성공할 수 있습니다.
![](//mc.qcloudimg.com/static/img/c3cba398e89f643c58a742e720dbd955/image.png)
그러므로 대부분 시나리오를 놓고 말하면 자체의 사용 시나리오에 따라 가장 작은 구성을 사용하여 보안성을 확보할 것을 권장합니다.
## CORS 구성 항목 설명
CORS 구성에는 아래 몇 가지 항목이 있습니다.
### 출처 Origin
크로스 도메인 요청을 허용하는 출처입니다.
- 여러 개 출처를 동시에 지정할 수 있고 각 행에는 오직 하나만 입력할 수 있습니다.
- 구성은 `*`를 지원하여 전체 도메인 이름을 모두 허용한다는 것을 표시하며 이 항목은 추천하지 않습니다.
- 단일의 구체적인 도메인 이름을 지원합니다. 예를 들어 `http://www.abc.com`.
- 2차 와일드카드 도메인 이름을 지원합니다. 예를 들어 `http://*.abc.com`. 그러나 각 행에서 `*` 기호는 하나만 포함될 수 있습니다.
- 프로토콜 이름 HTTP 또는 HTTPS를 놓치지 않도록 주의를 돌리고 포트가 기본값 80이 아닐 경우 포트도 갖춰야 합니다.
### 작업 Methods
열거가 허용되는 크로스 도메인 요청 방법(한 개 또는 여러 개).
예를 들어: GET, PUT, POST, DELETE, HEAD.

### 허용된 헤더
허용하는 크로스 도메인 요청 헤더.
- 여러 개 출처를 동시에 지정할 수 있고 각 행에는 오직 하나만 입력할 수 있습니다.
- 헤더는 빠뜨리기 쉬우므로 특별 수요가 없는 상황에서는 *로 설정하시기를 권장하며 모두 허용됨을 나타냅니다.
- 대/소문자는 구분하지 않습니다.
- Access-Control-Request-Headers 중 지정한 각 헤더는 모두 반드시 Allowed-Header에 해당되는 항목이 있어야 합니다.

### 노출된 헤더
브라우저에 개방하는 헤더 리스트, 즉 사용자가 응용프로그램에서 접근하는 응답 헤더(예를 들어 한 개 Javascript의 XMLHttpRequest 객체)입니다.
- 자세한 구성은 응용프로그램의 수요에 따라 확인하여야 하고 기본값으로 Etag를 입력할 것을 권장합니다.
- 와일드카드 문자의 사용을 허용하지 않고 대/소문자에 구분하지 않으며 각 행에 한 개만 입력 가능합니다.

### 시간 초과 Max-Age
브라우저가 특정 리소스에 대한 실행 전 요청(OPTIONS 요청)을 발행한 순간부터 결과를 반환할 때까지의 지연이고 단위가 초입니다. 특별한 상황이 없으면 약간 크게 설정해도 됩니다. 예: 60초.
이 항목은 옵션입니다.

